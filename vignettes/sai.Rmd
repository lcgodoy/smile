---
title: "3. Areal Interpolation"
output: rmarkdown::html_vignette
bibliography: biblio.bib
vignette: >
  %\VignetteIndexEntry{3. Areal Interpolation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE
)
```


In applied settings, estimating socioeconomic and demographic variables for
different administrative regions within a city is often of interest. While areal
interpolation [AI, @goodchild1980areal] easily computes such estimates, it lacks
measures of uncertainty [@bradley2016bayesian]. Our package addresses this by
providing both areal interpolation and methods to approximate the variance of
estimates when the observed data's variance is known, as is common with survey
data.


This demonstration will utilize 2010 Brazilian Census data from Nova Lima. The
objective is to estimate some variables in a separate map of the same
municipality. The census map with the original data will be referred to as the
"source" map, while the map where the data will be estimated will be referred to
as the "target" map. In this example, the target map is artificially
generated. To initiate the process, the data and necessary packages can be
loaded using the code below. We recommend using a planar Coordinate Reference
System (CRS) when using this method.
```{r load-data}
library(sf)
library(smile)
library(ggplot2)

data(nl_ct)
nl_ct <- st_transform(nl_ct, 20823)
```

The code chunk below creates the synthetic target map.

```{r synthetic-data}
set.seed(2024)

## outer polygon
nl_outer <- nl_ct |>
  st_geometry() |>
  st_union() |>
  smile:::st_remove_holes()

## creating `target` data
points_nl <- st_sample(x = nl_outer,
                       size = 40)

nl_vor <- do.call(c, points_nl) |>
  ## voronoi tesselation
  st_voronoi(envelope = nl_outer) |> 
  st_collection_extract(type = "POLYGON") |>
  st_set_crs(st_crs(nl_ct)) |>
  st_intersection(nl_outer) |>
  st_as_sf()

## creating id variable
nl_vor <- transform(nl_vor, id = seq_len(NROW(nl_vor)))
```


Now, to estimate one (or several) variable observed at the `nl_ct` dataset into
the `nl_vor` data we can run the following command:

```{r est-1}
nl_ests <-
    ai(source = nl_ct,
       target = nl_vor,
       vars = c("hh_density",
                "avg_income",
                "avg_age"))

## displaying the result
nl_ests |>
  st_drop_geometry() |>
  head()
```

In the function above, `source` is the map/dataset where the variables to be
estimated are observed, while `target` is the map/dataset where the estimation
is desired. The `vars` argument is a character scalar (or vector) specifying the
variable(s) in `source` to be estimated in `target`. However, this function does
not quantify uncertainty in the estimates.


If the variance of the variable we wish to estimate in the target map is
available in the source map, we can use the `ai_var` function to quantify the
uncertainty around our point estimates. The function is similar to `ai`, but
with a few differences:

1. `vars` must be a single variable name.

1. `my_var` is a character indicating the variable in source containing the
   observed variable's variance.

1. `var_method` specifies the method for approximating variance: Moran's I
   ("MI") for autocorrelation-based approximation, or Cauchy-Schwarz ("CS") for
   an upper bound.

1. The current version only supports one variable at a time.

The `ai_var` function outputs the target dataset with two additional columns:
`est` (estimated variable) and `se_est` (approximate standard error). 

```{r est-2}
nl_est <-
    ai_var(source = nl_ct,
           target = nl_vor,
           vars = "hh_density",
           vars_var = "var_hhd",
           var_method = "MI")

## renaming geometry
st_geometry(nl_est) <- "geometry"
```

Below we use `ggplot2` to plot the observed and estimated "household density" in
the source and target maps, respectively.

```{r ggplot-obs-est}
viz_dt <-
    rbind(
        transform(nl_ct, source = "Observed",
                  est = hh_density)[c("source", "est")],
        transform(nl_est, source = "Estimated")[c("source", "est")]
    )

ggplot(data = viz_dt,
       aes(fill = est)) +
    geom_sf(color = 1, lwd = .1) +
    scale_fill_viridis_c(option = "H",
                         name = "Household \n density") +
    theme_bw() +
    facet_wrap( ~ source) +
    theme(axis.text = element_blank(),
          axis.ticks = element_blank())
```

Finally, the next map displays the uncertainty about the estimated household
density.

```{r ggplot-obs-est-viz, eval = TRUE, echo = FALSE}
ggplot(data = nl_est,
       aes(fill = se_est)) +
    geom_sf(color = 1, lwd = .1) +
    scale_fill_viridis_c(option = "H",
                         name = "SE(Household \n density)") +
    theme_bw() +
    theme(axis.text = element_blank(),
          axis.ticks = element_blank())
```

<!-- \lcg{fit the sentence below somewhere in the appendix:} -->
<!-- Oftentimes, the variance of each~$Y(B_j)$, $\text{Var}[Y(B_j)]$, is -->
<!-- also available from a census or survey.  -->


<!-- The confidence intervals for the Voronoi interpolation were constructed based on -->
<!-- a normal approximation and in Equation~\eqref{eq:cova}. -->


<!-- Voronoi interpolation is a nonparametric approach that interpolates $Y(B_j)$'s -->
<!-- to construct $Y(s_i)$'s. Define an $n \times m$ matrix -->
<!-- $\mathbf{W} = \{ w_{ij} \}$, where $w_{ij}$ is the weight associated with the -->
<!-- polygon $B_j$ in constructing $Y(s_i)$.  The Voronoi weights are -->
<!-- $w_{ij} = \lvert B_j \cap V_i \rvert / \lvert V_i \rvert$, where -->
<!-- $\lvert \cdot \rvert$ returns the area of a polygon \citep{goodchild1980areal, -->
<!--   gotway2002combining}.  The interpolation for $\hat Y(s_1, \ldots, s_n)$ is -->
<!-- constructed as -->
<!-- \begin{equation} -->
<!--   \label{eq:np-est} -->
<!--   \hat{Y}(s_1, \ldots, s_n) = \mathbf{W} -->
<!--   Y(B_1, \ldots, B_m), -->
<!-- \end{equation} -->
<!-- and implicitly assumes homogeneity within each areal unit. The expectation and -->
<!-- the variance of the predictor are, respectively, -->
<!-- \begin{align*} -->
<!--   \E[\hat{Y}(s_1, \ldots, s_n)] &= \mathbf{W} \E[Y(B_1, \ldots, B_m)]\\ -->
<!--   \text{Var}[\hat{Y}(s_1, \ldots, s_n)] &= \mathbf{W} -->
<!--                                             \text{Var}[Y(B_1, \ldots, B_m)] \mathbf{W}^{\top}. -->
<!-- \end{align*} -->
<!-- In practice, the covariance matrix $\text{Var}[Y(B_1, \ldots, B_m)]$ is unknown -->
<!-- and, consequently, needs to be estimated. In our application, we work census -->
<!-- data, the expectation $\E[Y(B_j)]$ and the marginal population variances -->
<!-- $\text{Var}[Y(B_j)]$ are observed. In survey data, uncertainty around the -->
<!-- estimates $Y(B_j)$ is commonly available and may be used to estimate the -->
<!-- marginal variances. However, in our experience, the off-diagonals entries of the -->
<!-- covariance matrix $\text{Var}[Y(B_1, \ldots, B_m)]$ are unavailable in both -->
<!-- cases and must be estimated or approximated. -->


<!-- The variance of each predictor $\text{Var}[\hat Y(s_i)]$ is needed as an -->
<!-- uncertainty measure, which has not been addressed in the literature. It relies on  -->
<!-- both the variances of $Y(B_j)$'s and their covariances: -->
<!-- \begin{align} -->
<!--   \label{eq:np-single-var} -->
<!--   \text{Var}[\hat{Y}(s_i)]  -->
<!--   = \sum_{j = 1}^m w^2_{ij} \text{Var} \left [ Y(B_j) \right ] + 2 \sum_{l -->
<!--   \neq j} w_{ij} w_{il} \textrm{Cov} \left[ Y(B_j), Y(B_l) \right], -->
<!-- \end{align} -->
<!-- where the variances and covariances terms involving regions such that -->
<!-- $V_i \cap B_j = \varnothing$ are discarded. For practical purposes, we propose -->
<!-- an approximation for $\textrm{Cov}[ Y(B_j), Y(B_l)]$ based on -->
<!-- Moran's~I~\citep{moran1950notes}, a global spatial -->
<!-- autocorrelation. Specifically, let $\rho_I$ be the Moran's~I calculated with a -->
<!-- weight matrix constructed with first-degree neighbors. That is, $\rho_I$ is the -->
<!-- average of the pairwise correlation for all neighboring pairs. If regions $B_j$ -->
<!-- and $B_l$ are neighbors of each other, we have -->
<!-- \begin{align} -->
<!--   \label{eq:cova} -->
<!--   \textrm{Cov} \left[ Y(B_j), Y(B_l) \right] -->
<!--   \approx \rho_I \sqrt{\text{Var}[Y(B_j)]  \text{Var}[Y(B_l)]}. -->
<!-- \end{align} -->
<!-- Otherwise, we set $\textrm{Cov} \left[ Y(B_j), Y(B_l) \right]$ to zero. -->
<!-- This approximation alleviates the conservativeness of using the upper bound from -->
<!-- the Cauchy--Schwartz inequality, in which case, $\rho_I$ is replaced -->
<!-- with~1. See~\ref{app:cov} for more details on the derivation. -->
<!-- Note that as the spatial dependence gets stronger, the variance of the -->
<!-- estimator increases, which is in contrast to the model-based approach in the -->
<!-- next subsection. -->


<!-- \section{Covariance Terms Approximation for Areal interpolation} -->
<!-- \label{app:cov} -->


<!-- \jy{redundant section; repeating equations in the text.} -->


<!-- We first propose an easily scalable extension of an existing nonparametric -->
<!-- interpolation approach that accounts for the observed variance information as -->
<!-- well as the spatial dependence at the census tract level based on an -->
<!-- approximation using MoranÂ´s~I \citep{moran1950notes}. -->


<!-- Using Equation~\eqref{eq:np-est}, the areal interpolation estimate for $Y(s_i)$ -->
<!-- is -->
<!-- \begin{align*} -->
<!--   \hat{Y}(s_i) & = \mathbf{w}^\top_i Y(B_1, \ldots, B_n) -->
<!--   = \sum_{j = 1}^m w_{ij} Y(B_j), -->
<!-- \end{align*} -->
<!-- where $\mathbf{w}_i$ is the $i$-th row of the matrix $\mathbf{W}$ defined in -->
<!-- Section~\ref{app:nonpar}. The derivation in Equation~\eqref{eq:np-single-var} -->
<!-- follows directly from the variance operator. For each $j$ and $l$, the -->
<!-- Cauchy--Schwartz inequality gives -->
<!-- \begin{equation} -->
<!--   \label{eq:cs_ineq} -->
<!--   \textrm{Cov}[Y(B_j), Y(B_l)] \leq \sqrt{\text{Var}[Y(B_j)] -->
<!--     \text{Var}[Y(B_l)]}, \quad \forall j, l = 1, \ldots, m. -->
<!-- \end{equation} -->
<!-- By combining Equations~\eqref{eq:cs_ineq} and~\eqref{eq:np-single-var}, we have -->
<!-- \begin{equation*} -->
<!--   \text{Var}[\hat{Y}(s_i)] \leq \sum_{j = 1}^m w^2_{ij} \text{Var} \left [ Y(B_j) \right ] + 2 \sum_{l -->
<!--     \neq j} w_{ij} w_{il} \sqrt{\text{Var}[Y(B_j)] -->
<!--     \text{Var}[Y(B_l)]}. -->
<!-- \end{equation*} -->
<!-- The proposition in Equation~\eqref{eq:cova} is the multiply the upper-bounds -->
<!-- given by Equation~\eqref{eq:cs_ineq} by the Moran's~I, denoted -->
<!-- $\rho_I \in (-1, 1)$, resulting in a less conservative approximation. -->

# Reference
